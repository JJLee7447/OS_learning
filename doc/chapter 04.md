# 保护模式入门

## 内存检测

OS 需要跑在不同的机器上，因此需要检测内存的大小，以便在内存中分配空间。

BIOS 0x15 0xe820  提供了内存检测功能 返回一个 ARDS

Address Range Descriptor Structure (ARDS 20 字节) 用于描述内存段的结构体


|  字节偏移量 | 属性名称     | 描述                             |
| ---------- | ------------ | -------------------------------- |
| 0          | BaseAddrLow  | 基地址的低 32 位                 |
| 4          | BaseAddrHigh | 基地址的高 32 位                 |
| 8          | LengthLow    | 内存长度的低 32 位，以字节为单位 |
| 12         | LengthHigh   | 内存长度的高 32 位，以字节为单位 |
| 16         | Type         | 本段内存的类型                   |

**Type字段**

| Type 值 | 名称                 | 描述                                                                                 |
| ------- | -------------------- | ------------------------------------------------------------------------------------ |
| 1       | AddressRangeMemory   | 这段内存可以被操作系统使用                                                           |
| 2       | AddressRangeReserved | 内存使用中或者被系统保留，操作系统不可以用此内存                                     |
| 3       |                      | 存储ACPI表，可以被操作系统回收。|
| 4       |                      | 操作系统不可使用这段内存。|
| 5       |                      | 已经损坏的内存区域，不可使用。|
| 其他    | 未定义               | 未定义，将来会用到．目前保留． 但是需要操作系统一样将其视为ARR(AddressRangeReserved) |

**int 0x15 中断**


| 寄存器或状态位 | 参数用途                                                                                                                                                                                                                                                                                                 |
| -------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| EAX            | 子功能号： EAX 寄存器用来指定子功能号，此处输入为 0xE820                                                                                                                                                                                                                                                 |
| EBX            | 内存信息需要按类型分多次返回，由于每次执行一次中断都只返回一种类型内存的ARDS 结构，所以要记录下一个待返回的内存ARDS，在下一次中断调用时通过此值告诉 BIOS 该返回哪个 ARDS，这就是后续值的作用。第一次调用时一定要置为0，EBX 具体值我们不用关注，字取决于具体 BIOS 的实现，每次中断返回后，BIOS 会更新此值 |
| ES: DI         | ARDS 缓冲区：BIOS 将获取到的内存信息写入此寄存器指向的内存，每次都以 ARDS 格式返回                                                                                                                                                                                                                       |
| ECX            | ARDS 结构的字节大小：用来指示 BIOS 写入的字节数。调用者和 BIOS 都同时支持的大小是 20 字节，将来也许会扩展此结构                                                                                                                                                                                          |
| EDX            | 固定为签名标记 `0x534d4150`，此十六进制数字是字符串 `SMAP` 的ASCII 码： BIOS 将调用者正在请求的内存信息写入 ES: DI 寄存器所指向的ARDS 缓冲区后，再用此签名校验其中的信息                                                                                                                                 |

在 loader.asm 中加入内存检测
```s
detect_memory:
    xor ebx, ebx                    ; 将ebx清零 xor 效率高于 mov

                                    ; 将 es:edi 指向 adrs_buffer
    mov ax,0
    mov es,ax                       
    mov edi,adrs_buffer             

    mov edx, 0x534d4150             ; "SMAP" 固定签名

.next
    mov eax, 0xe820                 ; BIOS 中断 0x15 功能号
    mov ecx, 20                     ; adrs 大小 单位字节

    int 0x15                        ; 调用 BIOS 中断

                                    ; 检测返回值
    jc error                        ; 如果 CF=1 则发生错误，跳转到 error 标号处  
    add di,cx                       ; 将缓存指针指向下一个结构体

    inc word [adrs_count]           ; 将结构体数量加一

    cmp ebx,0                       ; ebx 为 0 说明已经遍历完所有结构体,检测结束
    jne .next                       ; 如果 ebx 不为 0 则继续循环

    mov si,detecting
    call print

    xchg bx,bx                      ; bochs 魔数断点


                                    ; 将adrs 缓冲区内容送入 eax, ebx ,edx 查看
    mov cx,[adrs_count]             ; 将结构体数量存入 ax

    mov si,0                         ; 初始化结构体指针

.show:
    mov eax, [adrs_buffer+si]       
    mov ebx, [adrs_buffer+si+8]
    mov edx, [adrs_buffer+si+16]
    add si, 20
    xchg bx,bx 
    loop .show
```